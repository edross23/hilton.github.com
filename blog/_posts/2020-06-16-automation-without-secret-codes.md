---
title: Automation without the secret codes
description: How no-code automation modernises programming
layout: hh
tags: NoCode
image: hieroglyphics.jpg
---

![Hieroglyphics on papyrus](hieroglyphics.jpg)

<a class="unsplash" href="https://www.flickr.com/photos/8604504@N03/44423410540" rel="noopener noreferrer" title="Photo by Justin Otto"><span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><title>unsplash-logo</title><path d="M20.8 18.1c0 2.7-2.2 4.8-4.8 4.8s-4.8-2.1-4.8-4.8c0-2.7 2.2-4.8 4.8-4.8 2.7.1 4.8 2.2 4.8 4.8zm11.2-7.4v14.9c0 2.3-1.9 4.3-4.3 4.3h-23.4c-2.4 0-4.3-1.9-4.3-4.3v-15c0-2.3 1.9-4.3 4.3-4.3h3.7l.8-2.3c.4-1.1 1.7-2 2.9-2h8.6c1.2 0 2.5.9 2.9 2l.8 2.4h3.7c2.4 0 4.3 1.9 4.3 4.3zm-8.6 7.5c0-4.1-3.3-7.5-7.5-7.5-4.1 0-7.5 3.4-7.5 7.5s3.3 7.5 7.5 7.5c4.2-.1 7.5-3.4 7.5-7.5z"></path></svg></span><span>Justin Otto • CC BY 2.0</span></a>

These days, people use no-code tools to create product prototypes, publish web sites, and automate office work.
I work with people who want to automate business processes within their company.
Half of the software developers I talk to see no-code automation as a misguided attempt to make programming obsolete.
The other half dismiss what they see as unacceptable limitations, or _dumbing down_ programming.
Both sides get it wrong.

## The GUI discoverability revelation

A few decades ago, the 1990s’ graphical user interfaces (GUI) replaced the 1980s’ command line interfaces, for most people using computers;
Mac OS and Windows, instead of MS-DOS.
GUIs took over, among other reasons, because more people could figure them out.

The 1992 [Macintosh Human Interface Guidelines](https://dl.acm.org/doi/book/10.5555/573097) explain that:

> The Macintosh desktop works according to two fundamental paradigms.
> Both paradigms share two basic assumptions:
> that users can see on the screen what they’re doing and 
> that users can point at what they see.

This _discoverability_ made GUI applications easier to learn than the equivalent command-line tools, especially for infrequent use.
A Unix-style operating system, in comparison, can be great for expert users;
a nice place to live, but you wouldn’t want to visit.

## Discoverability in text-based programming

Anyone learning a conventional programming language faces the same problem as someone using a command line (or 
[text adventure](https://en.wikipedia.org/wiki/Interactive_fiction)) for the first time:
finding out what you can type.

<img src="/picture/illustration/black_cave.gif" style="width:400px; height:300px;
image-rendering: optimizeSpeed; image-rendering: -moz-crisp-edges; image-rendering: -o-crisp-edges; image-rendering: -webkit-optimize-contrast; image-rendering: pixelated; image-rendering: optimize-contrast; -ms-interpolation-mode: nearest-neighbor;" alt="A command-line interface that looks like a text adventure">

Meanwhile, most professional programmers find 
[code completion](https://en.wikipedia.org/wiki/Autocomplete) indispensable,
such as this example where a menu of options pops up as you type, so you can find something called `PlayerRole`:

![Demo of autocompletion in a code editor](code-autocompletion.gif)

Code completion doesn’t help that much, though.
When learning programming, source code remains a kind of _secret code_.

## Programming without coding

As with using a new command-line interface, _not knowing what to type_ makes coding hard, not the actual programming.
That might sound odd, if you usually treat _coding_ and _programming_ as synonyms.
But imagine if they meant different things!

Wikipedia introduces [computer programming](https://en.wikipedia.org/wiki/Computer_programming)
by defining it broadly as:

> the process of designing and building an executable computer program to accomplish a specific computing result.

This clearly includes non-traditional programming environments, such as spreadsheets, 
[Scratch](https://en.wikipedia.org/wiki/Scratch_(programming_language)), 
workflow automation platforms, and other 
[visual programming](https://en.wikipedia.org/wiki/Visual_programming_language) environments.
These environments replace text-based source code with something more visual, resulting in _no-code_ tools.

## The no-code alternative

While no-code tools have a complicated set of pros and cons, they make programming dramatically more accessible to people who don’t do it full-time for long periods - months or years.
A full-time programmer doesn't need this accessibility as much, because they can learn the secret codes
(or at least how to look them up on a Q&A web site).

More importantly, perhaps, accessible tools _invite_ beginners, while text-based coding _excludes_ them.
More accurately, the professional programming culture that glorifies 1960s-style text-based tools actively excludes all kinds of people.
No-code tools threaten that kind of gatekeeping.

Switching from code-based to no-code tools involves many trade-offs, so instead of arguing that one doesn’t work or has no value, you might learn more from identifying the benefits of the no-code alternative, and thinking about what you might trade in to get them.
